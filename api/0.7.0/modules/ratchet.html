<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8"/>
<title>Reference</title>
<link rel="stylesheet" href="../luadoc.css" type="text/css"/>
 
</head>
<body>
<div class="floating-top-bar">
<div class="top-bar-left top-bar-text"><a href="/">Home</a></div>
<div class="top-bar-middle top-bar-text">Ratchet Library :: API Reference</div>
<div class="top-bar-right top-bar-text">
<a href="/api/latest">API</a>
&nbsp;<b>&middot;</b>&nbsp;
<a href="/pages/TOC">Manual</a>
</div>
</div>
<div id="container">
<div id="product">
<div id="product_logo"></div>
<div id="product_name"><big><b></b></big></div>
<div id="product_description"></div>
</div>  
<div id="main">
<div id="navigation">
<h1>LuaDoc</h1>
<ul>
<li><a href="../index.html">Index</a></li>
</ul>
 
<h1>Modules</h1>
<ul>
<li><strong>ratchet</strong></li>
<li>
<a href="../modules/ratchet.dns.html">ratchet.dns</a>
</li>
<li>
<a href="../modules/ratchet.http.client.html">ratchet.http.client</a>
</li>
<li>
<a href="../modules/ratchet.http.server.html">ratchet.http.server</a>
</li>
<li>
<a href="../modules/ratchet.smtp.client.html">ratchet.smtp.client</a>
</li>
<li>
<a href="../modules/ratchet.smtp.server.html">ratchet.smtp.server</a>
</li>
<li>
<a href="../modules/ratchet.socket.html">ratchet.socket</a>
</li>
<li>
<a href="../modules/ratchet.socketpad.html">ratchet.socketpad</a>
</li>
<li>
<a href="../modules/ratchet.ssl.html">ratchet.ssl</a>
</li>
<li>
<a href="../modules/ratchet.ssl.session.html">ratchet.ssl.session</a>
</li>
<li>
<a href="../modules/ratchet.timerfd.html">ratchet.timerfd</a>
</li>
<li>
<a href="../modules/ratchet.zmqsocket.html">ratchet.zmqsocket</a>
</li>
</ul>
 
</div> 
<div id="content">
<h1>Module <code>ratchet</code></h1>
<p>The purpose of the ratchet library is to provide a generic socket control mechanism for large numbers of sockets without using threads or losing the ease of synchronous socket programming. Along with networking, the library provides a sort of kernel to allow side-by-side execution of different streams of logic.</p>
<h2>Functions</h2>
<table class="function_list">
<tr>
<td class="name" nowrap><a href="#attach">attach</a>&nbsp;(self, func, ...)</td>
<td class="summary">Queues a new thread for execution.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#attach_background">attach_background</a>&nbsp;(self, func, ...)</td>
<td class="summary">Queues a new thread for execution.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#get_method">get_method</a>&nbsp;(self)</td>
<td class="summary">Returns the polling method used behind-the-scenes by libevent.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#loop">loop</a>&nbsp;(self)</td>
<td class="summary">Starts the main loop.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#new">new</a>&nbsp;()</td>
<td class="summary">Constructs and returns a new ratchet object.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#pause">pause</a>&nbsp;(self)</td>
<td class="summary">Pauses the current thread indefinitely.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#running_thread">running_thread</a>&nbsp;(self)</td>
<td class="summary">Returns the Lua thread object that is currently running, or nil for the main thread.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#set_error_handler">set_error_handler</a>&nbsp;(self, func, ...)</td>
<td class="summary">Sets the new error handler for threads.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#thread_space">thread_space</a>&nbsp;(self, premade)</td>
<td class="summary">Returns a table that is specific to the currently-running thread that can be used as scratch-space for thread-scope data.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#timer">timer</a>&nbsp;(self, seconds)</td>
<td class="summary">Pauses the current thread for the given period.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#unpause">unpause</a>&nbsp;(self, thread, ...)</td>
<td class="summary">Unpauses the given thread.</td>
</tr>
<tr>
<td class="name" nowrap><a href="#wait_all">wait_all</a>&nbsp;(self, threads)</td>
<td class="summary">Pauses the current thread until all threads listed in the given table have completed their execution either normally or by error.</td>
</tr>
</table>
<br/>
<br/>
<h2><a name="functions"></a>Functions</h2>
<dl class="function">
<dt><a name="attach"></a><strong>attach</strong>&nbsp;(self, func, ...)</dt>
<dd>
Queues a new thread for execution. The thread calls func and gives it any extra arguments as its parameters. The thread is not started by this method, instead it is started on next iteration of the loop. All threads attached with this method must be completed before loop() will finish.
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
<li>
func: the function to run in the thread.
</li>
<li>
...: extra parameters to function.
</li>
</ul>
<h3>Return value:</h3>
a Lua thread object.
</dd>
<dt><a name="attach_background"></a><strong>attach_background</strong>&nbsp;(self, func, ...)</dt>
<dd>
Queues a new thread for execution. The thread calls func and gives it any extra arguments as its parameters. The thread is not started by this method, instead it is started on next iteration of the loop. Threads attached with this method as opposed to attach() will be destroyed when loop() finishes, whether completed or not.
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
<li>
func: the function to run in the thread.
</li>
<li>
...: extra parameters to function.
</li>
</ul>
<h3>Return value:</h3>
a Lua thread object.
</dd>
<dt><a name="get_method"></a><strong>get_method</strong>&nbsp;(self)</dt>
<dd>
Returns the polling method used behind-the-scenes by libevent.
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
</ul>
<h3>Return value:</h3>
a string identifying the kernel event mechanism (kqueue, epoll, etc.).
</dd>
<dt><a name="loop"></a><strong>loop</strong>&nbsp;(self)</dt>
<dd>
Starts the main loop. Every iteration of this loop runs all new threads, runs all recently unpaused threads, runs all threads that are done waiting on others, and finally starts waiting for and handling network/socket events. The loop will continue until all threads created with attach() are completed.
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
</ul>
</dd>
<dt><a name="new"></a><strong>new</strong>&nbsp;()</dt>
<dd>
Constructs and returns a new ratchet object. This also creates a new libevent control structure that is freed when the object is collected.
<h3>Return value:</h3>
a new ratchet object.
</dd>
<dt><a name="pause"></a><strong>pause</strong>&nbsp;(self)</dt>
<dd>
Pauses the current thread indefinitely. The thread must be resumed by a call to unpause() from another thread.
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
</ul>
<h3>Return value:</h3>
any extra arguments passed to unpause() from other thread.
</dd>
<dt><a name="running_thread"></a><strong>running_thread</strong>&nbsp;(self)</dt>
<dd>
Returns the Lua thread object that is currently running, or nil for the main thread.
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
</ul>
<h3>Return value:</h3>
thread object or nil.
</dd>
<dt><a name="set_error_handler"></a><strong>set_error_handler</strong>&nbsp;(self, func, ...)</dt>
<dd>
Sets the new error handler for threads. The scope of the error handler depends on where this method is called. Calling from the main thread will use this handler as the default. Error handlers set in threads apply only to that thead. Extra arguments to this function are given to the handler function. The last parameter in the call will be the error object.
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
<li>
func: the function to call.
</li>
<li>
...: extra parameters to the function, before error object.
</li>
</ul>
</dd>
<dt><a name="thread_space"></a><strong>thread_space</strong>&nbsp;(self, premade)</dt>
<dd>
Returns a table that is specific to the currently-running thread that can be used as scratch-space for thread-scope data. This table is not created until the first time this method is called for in thread.
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
<li>
premade: optionally pass in a pre-existing object to be stored as the thread's scratch space instead of the default a new table.
</li>
</ul>
<h3>Return value:</h3>
a table specific to the current thread.
</dd>
<dt><a name="timer"></a><strong>timer</strong>&nbsp;(self, seconds)</dt>
<dd>
Pauses the current thread for the given period.
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
<li>
seconds: resume thread after this many seconds elapse.
</li>
</ul>
</dd>
<dt><a name="unpause"></a><strong>unpause</strong>&nbsp;(self, thread, ...)</dt>
<dd>
Unpauses the given thread. The paused thread will resume on next iteration of the main loop. Extra parameters to this function will be given to the paused thread as return values from pause().
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
<li>
thread: the thread to unpause.
</li>
<li>
...:
</li>
</ul>
</dd>
<dt><a name="wait_all"></a><strong>wait_all</strong>&nbsp;(self, threads)</dt>
<dd>
Pauses the current thread until all threads listed in the given table have completed their execution either normally or by error.
<h3>Parameters</h3>
<ul>
<li>
self: the ratchet object.
</li>
<li>
threads: table containing threads to wait for.
</li>
</ul>
</dd>
</dl>
</div>  
</div>  
<div id="about">
</div>  
</div>  
</body>
</html>
